<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cursor Rules Builder â€” offline</title>
  <style>
    :root { --gap: 12px; --radius: 12px; }
    * { box-sizing: border-box; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; background: #0b1220; color: #e8eefb; }
    header { padding: 20px; border-bottom: 1px solid #21314f; background: #0e1628; position: sticky; top: 0; z-index: 5; }
    h1 { margin: 0 0 8px; font-size: 20px; }
    .sub { opacity: .85; font-size: 13px; }
    main { padding: 20px; display: grid; gap: var(--gap); max-width: 1300px; margin: 0 auto; }
    .row { display: flex; flex-wrap: wrap; gap: var(--gap); align-items: flex-end; }
    .card { background: #101a30; border: 1px solid #22365c; border-radius: var(--radius); padding: 16px; }
    .toolbar .btn { margin-right: 8px; }
    .btn { background: #1c2b4b; color: #e8eefb; border: 1px solid #2a4476; padding: 10px 14px; border-radius: 10px; cursor: pointer; font-weight: 600; }
    .btn:hover { background: #24365f; }
    .btn.ghost { background: transparent; border-color: #2a4476; }
    .btn.warn { background: #3b2640; border-color: #6a2b70; }
    .grid { display: grid; gap: var(--gap); }
    .fields { display: grid; gap: var(--gap); grid-template-columns: repeat(2, 1fr); }
    .preset-field { max-width: 300px; }
    .preset-field select { font-size: 14px; }
    .preset-field button { width: 100%; }
    .field { display: grid; gap: 6px; }
    .field label { font-size: 12px; opacity: .9; }
    input[type="text"], textarea, select { background: #0c1527; color: #e8eefb; border: 1px solid #29406c; border-radius: 10px; padding: 10px 12px; font: inherit; }
    textarea { min-height: 140px; width: 100%; }
    .rule { position: relative; }
    .rule h3 { margin: 0 0 8px; font-size: 16px; }
    .rule-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .muted { opacity: .75; font-size: 12px; }
    .hl { color: #b0c9ff; }
    .footer-actions { display: flex; gap: 10px; flex-wrap: wrap; }
    code.inline { background: #0c1527; padding: 2px 6px; border-radius: 6px; border:1px solid #22365c; }
    .out { white-space: pre; background: #0c1527; padding: 12px; border:1px solid #22365c; border-radius: 10px; overflow:auto; }
    
    /* ê²€ìƒ‰ ê°€ëŠ¥í•œ selectbox ìŠ¤íƒ€ì¼ */
    .searchable-select {
      position: relative;
    }
    .searchable-select select {
      display: none;
    }
    .select-selected {
      background-color: #0c1527;
      border: 1px solid #29406c;
      border-radius: 10px;
      padding: 10px 12px;
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    .select-selected:after {
      position: absolute;
      content: "";
      top: 50%;
      right: 10px;
      width: 0;
      height: 0;
      border: 6px solid transparent;
      border-color: #e8eefb transparent transparent transparent;
      transform: translateY(-50%);
    }
    .select-selected.select-arrow-active:after {
      border-color: transparent transparent #e8eefb transparent;
      top: 20%;
    }
    .select-items {
      position: absolute;
      background-color: #0c1527;
      top: 100%;
      left: 0;
      right: 0;
      z-index: 99;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #29406c;
      border-top: none;
      border-radius: 0 0 10px 10px;
    }
    .select-hide {
      display: none;
    }
    .select-items div {
      padding: 10px 12px;
      cursor: pointer;
      user-select: none;
    }
    .select-items div:hover, .same-as-selected {
      background-color: rgba(255, 255, 255, 0.1);
    }
    .select-search {
      padding: 10px 12px;
      border: none;
      border-bottom: 1px solid #29406c;
      background-color: #0c1527;
      color: #e8eefb;
      width: 100%;
      outline: none;
    }
  </style>
</head>
<body>
  <header>
    <h1>Cursor Rules Builder <span class="sub">â€” ".mdc" íŒŒì¼ì„ ë§Œë“¤ì–´ <code class="inline">.cursor/rules</code>ì— ë¶™ì—¬ë„£ê¸°</span></h1>
    <div class="sub">ì˜¤í”„ë¼ì¸ ë‹¨ì¼ HTML. ê³µí†µ/í”„ë¡œì íŠ¸ ì§€ì¹¨ì„ ì…ë ¥í•˜ê³ , frontmatter(<code class="inline">alwaysApply</code>, <code class="inline">globs</code>)ê°€ í¬í•¨ëœ .mdcë¥¼ ìƒì„±í•©ë‹ˆë‹¤.</div>
    <div id="version-info" class="sub" style="margin-top: 8px; font-size: 12px; opacity: 0.7;"></div>
  </header>

  <main>
    <section class="card toolbar">
      <div class="row">
        <button class="btn" id="addRule">+ ê·œì¹™ ì¶”ê°€</button>
        <!-- <button class="btn" id="loadDefaults">ë³´ì•ˆ ê¸°ë³¸ + í”„ë¡œì íŠ¸ í…œí”Œë¦¿ ë¶ˆëŸ¬ì˜¤ê¸°</button> -->
        <div class="field preset-field">
          <label>ğŸ¯ ê°œë°œ í™˜ê²½ë³„ í”„ë¦¬ì…‹</label>
          <select id="presetSelector">
            <option value="">-- í”„ë¦¬ì…‹ì„ ì„ íƒí•˜ì„¸ìš” --</option>
          </select>
          <!-- <button class="btn" id="loadSelectedPreset" style="margin-top: 5px;">ì„ íƒí•œ í”„ë¦¬ì…‹ ë¶ˆëŸ¬ì˜¤ê¸°</button> -->
        </div>
        <button class="btn" id="downloadAll">ëª¨ë“  ê·œì¹™ .mdc ì €ì¥</button>
        <button class="btn ghost" id="clearAll">ì´ˆê¸°í™”</button>
        
        <!-- files.json í‚¤ ì„ íƒ ì˜µì…˜ ì¶”ê°€ -->
        <div class="field" style="margin-left: auto;">
          <label>files.json í‚¤ ì„ íƒ</label>
          <select id="fileKeySelector">
            <option value="path" selected>path</option>
            <option value="raw_url">raw_url</option>
          </select>
        </div>
      </div>
      <div class="muted" style="margin-top:8px;">TIP: ê³µí†µ ê·œì¹™ì€ <span class="hl">Scope = Always</span>ë¡œ ì„¤ì •í•˜ë©´ ì „ ë¦¬í¬ì—ì„œ í•­ìƒ ë¡œë“œë©ë‹ˆë‹¤. í”„ë¡œì íŠ¸ íŠ¹í™” ê·œì¹™ì€ ë³´í†µ <span class="hl">Scope = Auto</span>ë¡œ ë‘ê³ , <code class="inline">globs</code>ëŠ” <code class="inline">**/*</code>ë¡œ ìœ ì§€í•˜ì„¸ìš”.</div>
    </section>

    <section id="rules" class="grid"></section>

  </main>

  <template id="ruleTmpl">
    <div class="card rule">
      <h3>ê·œì¹™</h3>
      <div class="fields">
        <div class="field">
          <label>íŒŒì¼ëª… (.mdc)</label>
          <div class="searchable-select">
            <select class="f-name">
              <option value="">-- íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš” --</option>
            </select>
            <div class="select-selected">-- íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš” --</div>
            <div class="select-items select-hide">
              <input type="text" class="select-search" placeholder="ê²€ìƒ‰...">
            </div>
          </div>
          <div class="muted" style="margin-top: 5px; font-size: 12px;">íŒŒì¼ ì„ íƒ ì‹œ ìë™ìœ¼ë¡œ ë‚´ìš©ì´ ë¡œë”©ë©ë‹ˆë‹¤</div>
        </div>
        <div class="field">
          <label>ì„¤ëª… (description)</label>
          <input type="text" class="f-desc" placeholder="Organization Security Baseline" />
        </div>
        <div class="field">
          <label>Scope</label>
          <select class="f-scope">
            <option>Always</option>
            <option selected>Auto</option>
            <option>Manual</option>
          </select>
        </div>
        <div class="field">
          <label>globs (Auto/Alwaysì—ì„œë§Œ ì‚¬ìš©, ì˜ˆ: **/*)</label>
          <input type="text" class="f-globs" placeholder="**/*" />
        </div>
      </div>

      <div class="field" style="margin-top:12px;">
        <label>ë‚´ìš© (Markdown ë³¸ë¬¸)</label>

        <div class="row" style="gap:8px; margin-bottom:6px;">
          <span class="muted">ì¢Œ: í•œêµ­ì–´ / ìš°: English</span>
          <span class="muted">â€” â€œëª¨ë“  ê·œì¹™ .mdc ì €ì¥â€ì€ <strong>English</strong> ê¸°ì¤€</span>
        </div>

        <div class="row" style="gap:8px;">
          <div style="flex:1; min-width:300px;">
            <label class="muted">KR</label>
            <textarea class="f-body-kr" placeholder="# ì œëª© (KR) ..."></textarea>
          </div>
          <div style="flex:1; min-width:300px;">
            <label class="muted">EN</label>
            <textarea class="f-body-en" placeholder="# Title (EN) ..."></textarea>
          </div>
        </div>
      </div>

      <div class="rule-actions" style="margin-top:12px;">
        <button class="btn" data-action="preview">ë¯¸ë¦¬ë³´ê¸°</button>
        <button class="btn" data-action="copy">ë‚´ìš© ë³µì‚¬</button>
        <button class="btn" data-action="download">.mdc ì €ì¥</button>
        <button class="btn warn" data-action="remove">ì‚­ì œ</button>
      </div>
      <details style="margin-top:10px;">
        <summary>ìƒì„± ê²°ê³¼ ë¯¸ë¦¬ë³´ê¸°</summary>
        <pre class="out"></pre>
      </details>
    </div>
  </template>

  <script>
    const $rules = document.getElementById('rules');
    const tmpl = document.getElementById('ruleTmpl');
    const fileKeySelector = document.getElementById('fileKeySelector');
    let currentFileKey = 'path';

    // GitHub Pages í”„ë¡œì íŠ¸ ì‚¬ì´íŠ¸ ë² ì´ìŠ¤ ê²½ë¡œ ë™ì  ê³„ì‚°
    function getBasePath() {
      const path = window.location.pathname;
      // ë¡œì»¬ ê°œë°œ: "/" ë˜ëŠ” GitHub Pages í”„ë¡œì íŠ¸: "/cursor-rules/"
      if (path === '/' || path.endsWith('/index.html')) {
        return './';  // ë¡œì»¬ ê°œë°œ
      }
      // GitHub Pages í”„ë¡œì íŠ¸ ì‚¬ì´íŠ¸ ê°ì§€
      if (path.includes('/cursor-rules/')) {
        return './';  // í˜„ì¬ ë””ë ‰í† ë¦¬ ê¸°ì¤€ ìƒëŒ€ê²½ë¡œ
      }
      return './';  // ê¸°ë³¸ê°’
    }

    const BASE_PATH = getBasePath();
    const IS_GITHUB_PAGES = window.location.pathname.includes('/cursor-rules/');
    console.log('Detected base path:', BASE_PATH, 'for location:', window.location.pathname);
    console.log('GitHub Pages project site:', IS_GITHUB_PAGES);

    // í˜ì´ì§€ ë¡œë“œ ì‹œ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
    document.addEventListener('DOMContentLoaded', async () => {
      await loadMdFileList();
      await loadVersionInfo(); // ë²„ì „ ì •ë³´ ë¡œë“œ
      await initPresetSelector(); // í”„ë¦¬ì…‹ ì„ íƒê¸° ì´ˆê¸°í™”
      initSearchableSelects();
    });

    // ë²„ì „ ì •ë³´ ë¡œë“œ ë° í‘œì‹œ
    async function loadVersionInfo() {
      try {
        const response = await fetch(BASE_PATH + 'version-info.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const versionInfo = await response.json();
        
        const versionInfoDiv = document.getElementById('version-info');
        versionInfoDiv.innerHTML = `
          <div>Branch: <strong>${versionInfo.branch}</strong></div>
          <div>Last Commit: <strong>${versionInfo.last_commit_id.substring(0, 7)}</strong> (${new Date(versionInfo.committed_at).toLocaleString()})</div>
          <div>Message: ${versionInfo.last_commit_message}</div>
          <div>Generated: ${new Date(versionInfo.generated_at).toLocaleString()}</div>
        `;
      } catch (error) {
        console.error('ë²„ì „ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        // ì˜¤ë¥˜ ë°œìƒ ì‹œ ë²„ì „ ì •ë³´ ì˜ì—­ ìˆ¨ê¸°ê¸°
        const versionInfoDiv = document.getElementById('version-info');
        versionInfoDiv.style.display = 'none';
      }
    }

    // files.json í‚¤ ì„ íƒ ë³€ê²½ ì´ë²¤íŠ¸
    fileKeySelector.addEventListener('change', (e) => {
      currentFileKey = e.target.value;
      loadMdFileList();
    });

    // ê²€ìƒ‰ ê°€ëŠ¥í•œ selectbox ì´ˆê¸°í™”
    function initSearchableSelects() {
      const selects = document.querySelectorAll('.searchable-select');
      selects.forEach(selectDiv => {
        const selectedDiv = selectDiv.querySelector('.select-selected');
        const itemsDiv = selectDiv.querySelector('.select-items');
        const searchInput = itemsDiv.querySelector('.select-search');
        const selectElement = selectDiv.querySelector('select');
        
        selectedDiv.addEventListener('click', (e) => {
          e.stopPropagation();
          closeAllSelect(selectedDiv);
          itemsDiv.classList.toggle('select-hide');
          selectedDiv.classList.toggle('select-arrow-active');
          // select-boxê°€ ì—´ë¦´ ë•Œ ê²€ìƒ‰ í•„ë“œì— í¬ì»¤ìŠ¤í•˜ê³  ê²€ìƒ‰ì–´ ì´ˆê¸°í™”
          if (!itemsDiv.classList.contains('select-hide')) {
            setTimeout(() => {
              searchInput.value = '';
              searchInput.focus();
              // ëª¨ë“  í•­ëª© ë‹¤ì‹œ í‘œì‹œ
              const items = itemsDiv.querySelectorAll('div:not(.select-search)');
              items.forEach(item => item.style.display = "");
            }, 100);
          }
        });
        
        // ê²€ìƒ‰ ì…ë ¥ í•„ë“œ í´ë¦­ ì‹œ select-boxê°€ ë‹«íˆì§€ ì•Šë„ë¡ ë°©ì§€
        searchInput.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        
        // ê²€ìƒ‰ í•„ë“œì—ì„œ í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬
        searchInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            e.stopPropagation();
            // ì²« ë²ˆì§¸ ë³´ì´ëŠ” í•­ëª© ì„ íƒ
            const visibleItems = Array.from(itemsDiv.querySelectorAll('div:not(.select-search)'))
              .filter(item => item.style.display !== 'none');
            if (visibleItems.length > 0) {
              visibleItems[0].click();
            }
          } else if (e.key === 'Escape') {
            e.preventDefault();
            e.stopPropagation();
            closeAllSelect();
          }
        });
        
        searchInput.addEventListener('input', (e) => {
          const filter = e.target.value.toUpperCase();
          const items = itemsDiv.querySelectorAll('div:not(.select-search)');
          items.forEach(item => {
            const txtValue = item.textContent || item.innerText;
            if (txtValue.toUpperCase().indexOf(filter) > -1) {
              item.style.display = "";
            } else {
              item.style.display = "none";
            }
          });
        });
        
        const options = selectElement.querySelectorAll('option');
        options.forEach(option => {
          if (option.value) {
            const item = document.createElement('DIV');
            item.innerHTML = option.innerHTML;
            item.addEventListener('click', (e) => {
              e.stopPropagation();
              selectedDiv.innerHTML = option.innerHTML;
              selectElement.value = option.value;
              closeAllSelect();
            });
            itemsDiv.appendChild(item);
          }
        });
      });
      
      document.addEventListener('click', closeAllSelect);
    }
    
    function closeAllSelect(elmnt) {
      const arrNo = [];
      const selectSelected = document.querySelectorAll('.select-selected');
      const selectItems = document.querySelectorAll('.select-items');
      for (let i = 0; i < selectSelected.length; i++) {
        if (elmnt == selectSelected[i]) {
          arrNo.push(i)
        } else {
          selectSelected[i].classList.remove('select-arrow-active');
        }
      }
      for (let i = 0; i < selectItems.length; i++) {
        if (arrNo.indexOf(i)) {
          selectItems[i].classList.add('select-hide');
        }
      }
    }

    async function loadMdFileList() {
      try {
        const response = await fetch(BASE_PATH + 'files.json');
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const files = await response.json();
        const bases = buildBaseIndex(files);

        // í…œí”Œë¦¿ì˜ select(ìƒˆ ê·œì¹™ìš©)ì— ì˜µì…˜ ì£¼ì…
        const templateSelects = tmpl.content.querySelectorAll('.searchable-select');
        templateSelects.forEach(templateSelectDiv => {
          const selectElement = templateSelectDiv.querySelector('select');
          const selectedDiv = templateSelectDiv.querySelector('.select-selected');
          const itemsDiv = templateSelectDiv.querySelector('.select-items');

          while (selectElement.options.length > 1) selectElement.remove(1);
          const searchInput = itemsDiv.querySelector('.select-search');
          itemsDiv.innerHTML = '';
          itemsDiv.appendChild(searchInput);

          bases.forEach(b => {
            const option = document.createElement('option');
            option.value = b.base;       // í•­ìƒ base path
            option.textContent = b.base;
            selectElement.appendChild(option);

            const item = document.createElement('DIV');
            item.innerHTML = b.base;
            item.addEventListener('click', (e) => {
              e.stopPropagation();
              selectedDiv.innerHTML = b.base;
              selectElement.value = b.base;
              closeAllSelect();
            });
            itemsDiv.appendChild(item);
          });

          selectedDiv.innerHTML = "-- íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš” --";
          selectElement.value = "";
        });

        // ì´ë¯¸ ì¶”ê°€ëœ ê·œì¹™ ì¹´ë“œë“¤ì˜ select ê°±ì‹ 
        document.querySelectorAll('.rule .searchable-select').forEach(selectDiv => {
          const selectElement = selectDiv.querySelector('select');
          const selectedDiv = selectDiv.querySelector('.select-selected');
          const itemsDiv = selectDiv.querySelector('.select-items');
          const ruleCard = selectDiv.closest('.rule');

          while (selectElement.options.length > 1) selectElement.remove(1);
          const searchInput = itemsDiv.querySelector('.select-search');
          itemsDiv.innerHTML = '';
          itemsDiv.appendChild(searchInput);

          bases.forEach(b => {
            const option = document.createElement('option');
            option.value = b.base;
            option.textContent = b.base;
            selectElement.appendChild(option);

            const item = document.createElement('DIV');
            item.innerHTML = b.base;
            item.addEventListener('click', async (e) => {
              e.stopPropagation();
              selectedDiv.innerHTML = b.base;
              selectElement.value = b.base;
              closeAllSelect();
              // íŒŒì¼ ì„ íƒ ë³€ê²½ ì‹œ ìë™ìœ¼ë¡œ ë‚´ìš© ë¡œë“œ
              await loadFileContent(ruleCard);
            });
            itemsDiv.appendChild(item);
          });

          const currentValue = selectElement.value;
          if (currentValue) {
            const currentOption = Array.from(selectElement.options).find(opt => opt.value === currentValue);
            if (currentOption) selectedDiv.innerHTML = currentOption.textContent;
          } else {
            selectedDiv.innerHTML = "-- íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš” --";
          }
        });
      } catch (error) {
        console.error('íŒŒì¼ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
      }
    }



    function escapeYaml(str){
      if (!str) return '';
      // escape double quotes, newlines aren't used in description
      return String(str).replace(/"/g, '\\"');
    }

    function buildBaseIndex(files){
      const map = new Map();
      for (const f of files){
        const base = f.path.replace(/\.kr\.md$|\.en\.md$/i, '.md');
        const e = map.get(base) || { base, kr: null, en: null, plain: null };
        if (/\.kr\.md$/i.test(f.path)) e.kr = f;
        else if (/\.en\.md$/i.test(f.path)) e.en = f;
        else e.plain = e.plain || f; // ì²« plainì„ ë³´ì¡´
        map.set(base, e);
      }
      return Array.from(map.values()).sort((a,b)=>a.base.localeCompare(b.base));
    }


    function buildFrontmatter({desc, scope, globs}){
      const lines = ['---'];
      if (desc && desc.trim()) lines.push(`description: "${escapeYaml(desc.trim())}"`);
      if (scope === 'Always') lines.push('alwaysApply: true');
      if ((scope === 'Always' || scope === 'Auto') && globs && globs.trim()){
        lines.push('globs:');
        // support comma or whitespace separated patterns
        const parts = globs.split(/[,\n]/).map(s => s.trim()).filter(Boolean);
        for (const p of parts){ lines.push(`  - "${p.replace(/"/g, '\\"')}"`); }
      }
      lines.push('---');
      return lines.join('\n');
    }

    function ruleFromCard(card){
      return {
        name: card.querySelector('.f-name').value.trim(),
        desc: card.querySelector('.f-desc').value,
        scope: card.querySelector('.f-scope').value,
        globs: card.querySelector('.f-globs').value,
        bodyKr: card.querySelector('.f-body-kr').value,
        bodyEn: card.querySelector('.f-body-en').value
      };
    }

    function buildMDC({name, desc, scope, globs, bodyKr, bodyEn}){
      const fm = buildFrontmatter({desc, scope, globs});
      const body = (bodyEn && bodyEn.trim()) || (bodyKr && bodyKr.trim()) || '';
      return fm + '\n\n' + body + '\n';
    }


    function setPreview(card, text){ card.querySelector('.out').textContent = text; }

    function downloadText(filename, text){
      const blob = new Blob([text], {type: 'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename || 'rule.mdc';
      document.body.appendChild(a); a.click();
      a.remove(); URL.revokeObjectURL(url);
    }

    async function addRule(prefill){
      const node = tmpl.content.firstElementChild.cloneNode(true);
      if (prefill){
        node.querySelector('.f-desc').value = prefill.desc || '';
        node.querySelector('.f-scope').value = prefill.scope || 'Auto';
        node.querySelector('.f-globs').value = prefill.globs || '';
        node.querySelector('.f-body-kr').value = prefill.bodyKr || prefill.body || '';
        node.querySelector('.f-body-en').value = prefill.bodyEn || '';
      }
      // íŒŒì¼ ëª©ë¡ ë¡œë“œ
      await loadMdFileListForNewRule(node);
      
      // ê²€ìƒ‰ ê°€ëŠ¥í•œ selectbox ì´ˆê¸°í™”
      initSearchableSelectForRule(node);
      
      // basePathê°€ ìˆìœ¼ë©´ íŒŒì¼ëª… select boxë¥¼ ìë™ìœ¼ë¡œ ì„¤ì •
      if (prefill && prefill.basePath) {
        const selectDiv = node.querySelector('.searchable-select');
        const selectElement = selectDiv.querySelector('select');
        const selectedDiv = selectDiv.querySelector('.select-selected');
        
        // basePath ê°’ìœ¼ë¡œ select ì„¤ì •
        selectElement.value = prefill.basePath;
        selectedDiv.innerHTML = prefill.basePath;
        
        console.log(`Set file selection to: ${prefill.basePath}`);
      }
      
      node.addEventListener('click', async (e) => {
        const action = e.target.dataset.action;
        if (!action) return;
        const data = ruleFromCard(node);
        if (action === 'preview'){
          const out = buildMDC(data);
          setPreview(node, out);
        } else if (action === 'copy'){
          const out = buildMDC(data);
          navigator.clipboard.writeText(out).then(() => {
            e.target.textContent = 'ë³µì‚¬ë¨';
            setTimeout(() => e.target.textContent = 'ë‚´ìš© ë³µì‚¬', 1200);
          });

        } else if (action === 'download'){
          const out = buildMDC(data);
          const name = mdcNameFromSelectedValue(node.querySelector('.f-name').value);          
          downloadText(name, out);        

        } else if (action === 'remove'){
          node.remove();
        } else if (action === 'load-file-content') {
          await loadFileContent(node);
        }

     
      });
      $rules.appendChild(node);
    }

    function mdcNameFromSelectedValue(v){
      if (!v) return 'rule.mdc';
      const base = v.split('/').pop(); // path or raw_url ëª¨ë‘ ë§ˆì§€ë§‰ í† í° ì‚¬ìš©
      return base.replace(/\.md$/i, '.mdc') || 'rule.mdc';
    }

    // íŒŒì¼ ë‚´ìš© ë¡œë”© í•¨ìˆ˜ (ë³„ë„ ë¶„ë¦¬)
    async function loadFileContent(ruleCard) {
      const basePath = ruleCard.querySelector('.f-name').value; // í•­ìƒ cursor-rules/.../foo.md
      if (!basePath) {
        console.log('íŒŒì¼ì´ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
        return;
      }
      
      try {
        const fileListResponse = await fetch(BASE_PATH + 'files.json');
        if (!fileListResponse.ok) throw new Error(`HTTP error! status: ${fileListResponse.status}`);
        const files = await fileListResponse.json();

        // ë² ì´ìŠ¤ì—ì„œ KR/EN í›„ë³´ ê²½ë¡œ ë§Œë“¤ê¸°
        const krPath = basePath.replace(/\.md$/i, '.kr.md');
        const enPath = basePath.replace(/\.md$/i, '.en.md');

        // files.jsonì—ì„œ ì—”íŠ¸ë¦¬ ì°¾ê¸° (ì—†ìœ¼ë©´ fallback: plain/mdë¥¼ lang ë‹¨ì„œë¡œ)
        const krEntry =
          files.find(f => f.path === krPath) ||
          files.find(f => f.path === basePath && (f.lang === 'kr' || f.lang === 'und'));

        const enEntry =
          files.find(f => f.path === enPath) ||
          files.find(f => f.path === basePath && f.lang === 'en');

        const urlFor = (entry) => {
          if (!entry) return null;
          if (fileKeySelector.value === 'path') {
            let path = entry.path;
            
            // GitHub Pages í”„ë¡œì íŠ¸ ì‚¬ì´íŠ¸ì—ì„œëŠ” web/ ë””ë ‰í† ë¦¬ê°€ ë£¨íŠ¸ê°€ ë˜ë¯€ë¡œ
            // files.jsonì˜ cursor-rules/ ê²½ë¡œë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•´ì•¼ í•¨
            if (window.location.pathname.includes('/cursor-rules/')) {
              // pathê°€ ì´ë¯¸ cursor-rules/ë¡œ ì‹œì‘í•˜ë¯€ë¡œ ê·¸ëŒ€ë¡œ ì‚¬ìš©
              console.log(`loadFileContent GitHub Pages: ${path}`);
            }
            
            return BASE_PATH + path;
          }
          // raw_url ëª¨ë“œì¼ ë•ŒëŠ” GitHub URL ê·¸ëŒ€ë¡œ ì‚¬ìš©
          return entry.raw_url;
        };

        // ë³‘ë ¬ ë¡œë“œ
        const [krContent, enContent] = await Promise.all([
          (async () => {
            const u = urlFor(krEntry);
            if (!u) return '';
            const r = await fetch(u);
            if (!r.ok) throw new Error(`HTTP error (KR)! status: ${r.status}`);
            return await r.text();
          })(),
          (async () => {
            const u = urlFor(enEntry);
            if (!u) return '';
            const r = await fetch(u);
            if (!r.ok) throw new Error(`HTTP error (EN)! status: ${r.status}`);
            return await r.text();
          })(),
        ]);

        // ì¢Œ/ìš° ì±„ìš°ê¸° (ìˆì„ ë•Œë§Œ ê°±ì‹ )
        if (krContent) ruleCard.querySelector('.f-body-kr').value = krContent;
        if (enContent) ruleCard.querySelector('.f-body-en').value = enContent;

        // ì„¤ëª…/í‘œì‹œ ì—…ë°ì´íŠ¸
        const mdcFilename = basePath.split('/').pop().replace(/\.md$/i, '.mdc');
        const descBase = mdcFilename.replace(/\.mdc$/,'').replace(/[-_]/g,' ');
        ruleCard.querySelector('.f-desc').value =
          descBase.charAt(0).toUpperCase() + descBase.slice(1) + ` (from ${basePath})`;

        const selectDiv = ruleCard.querySelector('.searchable-select');
        selectDiv.querySelector('.select-selected').innerHTML = basePath;
        
        console.log(`íŒŒì¼ ë‚´ìš© ë¡œë”© ì™„ë£Œ: ${basePath}`);
      } catch (error) {
        console.error('íŒŒì¼ ë‚´ìš©ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        // ìë™ ë¡œë”©ì—ì„œëŠ” alert ëŒ€ì‹  console.errorë§Œ ì‚¬ìš©
      }
    }


    // ìƒˆë¡œìš´ ê·œì¹™ ì¹´ë“œì— íŒŒì¼ ëª©ë¡ ë¡œë“œ (ì •ì  JSON íŒŒì¼ ì‚¬ìš©)
    
    async function loadMdFileListForNewRule(ruleNode) {
      try {
        const response = await fetch(BASE_PATH + 'files.json');
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const files = await response.json();
        const bases = buildBaseIndex(files);

        const selectDiv = ruleNode.querySelector('.searchable-select');
        const selectElement = selectDiv.querySelector('select');
        const selectedDiv = selectDiv.querySelector('.select-selected');
        const itemsDiv = selectDiv.querySelector('.select-items');

        if (!selectElement) return;

        while (selectElement.options.length > 1) selectElement.remove(1);
        const searchInput = itemsDiv.querySelector('.select-search');
        itemsDiv.innerHTML = '';
        itemsDiv.appendChild(searchInput);

        bases.forEach(b => {
          const option = document.createElement('option');
          option.value = b.base;       // í•­ìƒ base path
          option.textContent = b.base;
          selectElement.appendChild(option);

          const item = document.createElement('DIV');
          item.innerHTML = b.base;
          item.addEventListener('click', async (e) => {
            e.stopPropagation();
            selectedDiv.innerHTML = b.base;
            selectElement.value = b.base;
            closeAllSelect();
            // íŒŒì¼ ì„ íƒ ë³€ê²½ ì‹œ ìë™ìœ¼ë¡œ ë‚´ìš© ë¡œë“œ
            const ruleCard = selectDiv.closest('.rule');
            if (ruleCard) {
              await loadFileContent(ruleCard);
            }
          });
          itemsDiv.appendChild(item);
        });

        selectedDiv.innerHTML = "-- íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš” --";
        selectElement.value = "";
      } catch (error) {
        console.error('íŒŒì¼ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
      }
    }

    
    // ìƒˆë¡œìš´ ê·œì¹™ ì¹´ë“œì— ëŒ€í•œ ê²€ìƒ‰ ê°€ëŠ¥í•œ selectbox ì´ˆê¸°í™”
    function initSearchableSelectForRule(ruleNode) {
        const selectDiv = ruleNode.querySelector('.searchable-select');
        if (!selectDiv) return;
        
        const selectedDiv = selectDiv.querySelector('.select-selected');
        const itemsDiv = selectDiv.querySelector('.select-items');
        const searchInput = itemsDiv.querySelector('.select-search');
        const selectElement = selectDiv.querySelector('select');
        
        selectedDiv.addEventListener('click', (e) => {
            e.stopPropagation();
            closeAllSelect(selectedDiv);
            itemsDiv.classList.toggle('select-hide');
            selectedDiv.classList.toggle('select-arrow-active');
            // select-boxê°€ ì—´ë¦´ ë•Œ ê²€ìƒ‰ í•„ë“œì— í¬ì»¤ìŠ¤í•˜ê³  ê²€ìƒ‰ì–´ ì´ˆê¸°í™”
            if (!itemsDiv.classList.contains('select-hide')) {
                setTimeout(() => {
                    searchInput.value = '';
                    searchInput.focus();
                    // ëª¨ë“  í•­ëª© ë‹¤ì‹œ í‘œì‹œ
                    const items = itemsDiv.querySelectorAll('div:not(.select-search)');
                    items.forEach(item => item.style.display = "");
                }, 100);
            }
        });
        
        // ê²€ìƒ‰ ì…ë ¥ í•„ë“œ í´ë¦­ ì‹œ select-boxê°€ ë‹«íˆì§€ ì•Šë„ë¡ ë°©ì§€
        searchInput.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // ê²€ìƒ‰ í•„ë“œì—ì„œ í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                e.stopPropagation();
                // ì²« ë²ˆì§¸ ë³´ì´ëŠ” í•­ëª© ì„ íƒ
                const visibleItems = Array.from(itemsDiv.querySelectorAll('div:not(.select-search)'))
                    .filter(item => item.style.display !== 'none');
                if (visibleItems.length > 0) {
                    visibleItems[0].click();
                }
            } else if (e.key === 'Escape') {
                e.preventDefault();
                e.stopPropagation();
                closeAllSelect();
            }
        });
        
        searchInput.addEventListener('input', (e) => {
            const filter = e.target.value.toUpperCase();
            const items = itemsDiv.querySelectorAll('div:not(.select-search)');
            items.forEach(item => {
                const txtValue = item.textContent || item.innerText;
                if (txtValue.toUpperCase().indexOf(filter) > -1) {
                    item.style.display = "";
                } else {
                    item.style.display = "none";
                }
            });
        });
        
        const options = selectElement.querySelectorAll('option');
        options.forEach(option => {
            if (option.value) {
                const item = document.createElement('DIV');
                item.innerHTML = option.innerHTML;
                item.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    selectedDiv.innerHTML = option.innerHTML;
                    selectElement.value = option.value;
                    closeAllSelect();
                    // íŒŒì¼ ì„ íƒ ë³€ê²½ ì‹œ ìë™ìœ¼ë¡œ ë‚´ìš© ë¡œë“œ
                    await loadFileContent(ruleNode);
                });
                itemsDiv.appendChild(item);
            }
        });
    }

    function normBase(p) {
      if (!p) return '';
      let s = String(p).trim();

      // ì•ë’¤ í”„ë¦¬í”½ìŠ¤ ì •ë¦¬
      s = s.replace(/^\.\/+/, '');
      s = s.replace(/^\/+/, '');

      // ë¹Œë“œ ì‚°ì¶œë¬¼ ê²½ë¡œ ì œê±°
      s = s.replace(/^web\/+/, '');

      // ì¤‘ë³µëœ cursor-rules/ ì ‘ë‘ ì •ê·œí™”
      // "cursor-rules/cursor-rules/x.md" -> "cursor-rules/x.md"
      s = s.replace(/^cursor-rules\/+cursor-rules\//, 'cursor-rules/');

      // GH Pages ì ˆëŒ€ê²½ë¡œ (ì˜ˆ: "/cursor-rules/foo.md") -> ìƒëŒ€ í‘œê¸°
      s = s.replace(/^cursor-rules\/+/, 'cursor-rules/');  // idempotent
      s = s.replace(/^\/?cursor-rules\/+/, 'cursor-rules/');

      // ìƒëŒ€ ê²½ë¡œë¼ë©´ repo ë£¨íŠ¸ ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™”
      if (!s.startsWith('cursor-rules/')) {
        s = 'cursor-rules/' + s;
      }

      // ì–¸ì–´ ì ‘ë¯¸ì‚¬ëŠ” .md ê¸°ì¤€ìœ¼ë¡œ í†µì¼
      s = s.replace(/\.kr\.md$/i, '.md').replace(/\.en\.md$/i, '.md');

      return s;
    }

    function candidateForms(basePath) {
      const abs = normBase(basePath);                      // "cursor-rules/a/b.md"
      const rel = abs.replace(/^cursor-rules\//, '');      // "a/b.md"
      const webAbs = 'web/' + abs;                         // "web/cursor-rules/a/b.md"
      const siteAbs = 'cursor-rules/' + rel;               // "cursor-rules/a/b.md" (same as abs, but ì•ˆì „í•˜ê²Œ)
      return Array.from(new Set([abs, rel, webAbs, siteAbs]));
    }

    function globToRegExp(glob){
      // ë§¤ìš° ë‹¨ìˆœí•œ glob: **, *, ? ë§Œ ì§€ì›
      const re = glob
        .replace(/[.+^${}()|[\]\\]/g, '\\$&')
        .replace(/\*\*/g, 'Â§Â§DOUBLESTARÂ§Â§')
        .replace(/\*/g, '[^/]*')
        .replace(/\?/g, '[^/]')
        .replace(/Â§Â§DOUBLESTARÂ§Â§/g, '.*');
      return new RegExp('^' + re + '$');
    }

    function anyMatch(forms, globs){
      if (!globs || globs.length === 0) return true;
      return forms.some(f => globs.some(g => globToRegExp(g).test(f)));
    }

    function noneMatch(forms, globs){
      if (!globs || globs.length === 0) return true;
      return forms.every(f => globs.every(g => !globToRegExp(g).test(f)));
    }

    function matchGlobs(path, include = ['**/*'], exclude = []){
      const incOk = include.length === 0 || include.some(g => globToRegExp(g).test(path));
      const excOk = exclude.every(g => !globToRegExp(g).test(path));
      return incOk && excOk;
    }
    // ì´ë¯¸ ìˆìœ¼ë‚˜, ì—¬ê¸° ë‹¤ì‹œ ëª…ì‹œ (bases: [{base,kr,en,plain}])
    function buildBaseIndex(files){
      const map = new Map();
      for (const f of files){
        const base = f.path.replace(/\.kr\.md$|\.en\.md$/i, '.md');
        const e = map.get(base) || { base, kr: null, en: null, plain: null };
        if (/\.kr\.md$/i.test(f.path)) e.kr = f;
        else if (/\.en\.md$/i.test(f.path)) e.en = f;
        else e.plain = e.plain || f;
        map.set(base, e);
      }
      return Array.from(map.values()).sort((a,b)=>a.base.localeCompare(b.base));
    }

    async function fetchPresets(url = 'cursor-rules/presets.json') {
      const res = await fetch(BASE_PATH + url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Failed to load presets: ${res.status}`);
      const json = await res.json();
      if (!Array.isArray(json.presets)) throw new Error('Invalid presets schema');
      return {
        presets: json.presets,
        categories: json.categories || {},
        version: json.version || 1
      };
    }

    async function fetchFilesJson(){
      const res = await fetch(BASE_PATH + 'files.json', { cache: 'no-store' });
      if (!res.ok) throw new Error(`files.json load failed: ${res.status}`);
      return await res.json();
    }

    function urlFor(entry){
      if (!entry) return null;
      if (fileKeySelector.value === 'path') {
        let path = entry.path;
        const originalPath = path;
        
        // GitHub Pages í”„ë¡œì íŠ¸ ì‚¬ì´íŠ¸ì—ì„œëŠ” web/ ë””ë ‰í† ë¦¬ê°€ ë£¨íŠ¸ê°€ ë˜ë¯€ë¡œ
        // files.jsonì˜ cursor-rules/ ê²½ë¡œë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•´ì•¼ í•¨
        if (window.location.pathname.includes('/cursor-rules/')) {
          // pathê°€ ì´ë¯¸ cursor-rules/ë¡œ ì‹œì‘í•˜ë¯€ë¡œ ê·¸ëŒ€ë¡œ ì‚¬ìš©
          console.log(`GitHub Pages: ${originalPath} -> ${path}`);
        }
        
        const finalUrl = BASE_PATH + path;
        console.log(`urlFor: ${originalPath} -> ${finalUrl}`);
        return finalUrl;
      }
      // raw_url ëª¨ë“œì¼ ë•ŒëŠ” GitHub URL ê·¸ëŒ€ë¡œ ì‚¬ìš©
      return entry.raw_url;
    }

    // basePath(â€¦/foo.md) â†’ [krContent, enContent] ë¡œë“œ
    async function loadPairForBase(files, basePath){
      const krPath = basePath.replace(/\.md$/i, '.kr.md');
      const enPath = basePath.replace(/\.md$/i, '.en.md');

      const krEntry =
        files.find(f => f.path === krPath) ||
        files.find(f => f.path === basePath && (f.lang === 'kr' || f.lang === 'und'));

      const enEntry =
        files.find(f => f.path === enPath) ||
        files.find(f => f.path === basePath && f.lang === 'en');

      const [krContent, enContent] = await Promise.all([
        (async()=>{ const u=urlFor(krEntry); if(!u) return ''; const r=await fetch(u); if(!r.ok) throw new Error(`KR fetch ${r.status}`); return r.text(); })(),
        (async()=>{ const u=urlFor(enEntry); if(!u) return ''; const r=await fetch(u); if(!r.ok) throw new Error(`EN fetch ${r.status}`); return r.text(); })()
      ]);
      return [await krContent, await enContent];
    }

    function buildMatcher(globs) {
      // globs: ë¬¸ìì—´ ë°°ì—´(ê²½ë¡œ/íŒ¨í„´ í˜¼í•©)
      // ê° í•­ëª©ì„ candidateFormsë¡œ í™•ì¥ + ì •ê·œí™”í•´ "ì§ì ‘ì¼ì¹˜ ì„¸íŠ¸"ì™€ "ì •ê·œì‹ ì„¸íŠ¸" ëª¨ë‘ ì¤€ë¹„
      const eqSet = new Set();   // ì™„ì „ì¼ì¹˜ìš©
      const reList = [];         // glob íŒ¨í„´ìš©

      (globs || []).forEach(g => {
        if (!g) return;
        const forms = candidateForms(g);
        forms.forEach(f => eqSet.add(f));
        // glob íŒ¨í„´ìœ¼ë¡œë„ ë™ì‘í•˜ê²Œ í•¨ (ì •ê·œí™”ëœ ëŒ€í‘œ absë§Œ ì‚¬ìš©)
        reList.push(globToRegExp(normBase(g)));
      });

      return {
        anyMatch(forms) {
          // 1) ì™„ì „ì¼ì¹˜ ë¨¼ì €
          for (const f of forms) if (eqSet.has(f)) return true;
          // 2) glob íŒ¨í„´
          for (const f of forms) {
            for (const re of reList) if (re.test(f)) return true;
          }
          return eqSet.size === 0 && reList.length === 0; // ë¹„ì–´ìˆìœ¼ë©´ í—ˆìš©
        },
        noneMatch(forms) {
          if (eqSet.size === 0 && reList.length === 0) return true;
          // eqSet/regex ì¤‘ í•˜ë‚˜ë¼ë„ ê±¸ë¦¬ë©´ ì œì™¸ ëŒ€ìƒ
          for (const f of forms) {
            if (eqSet.has(f)) return false;
            for (const re of reList) if (re.test(f)) return false;
          }
          return true;
        }
      };
    }

    function fileNameOf(p) {
      const s = normBase(p);
      const i = s.lastIndexOf('/');
      return i >= 0 ? s.slice(i + 1) : s;
    }


    async function expandPresetToBases(preset, bases) {
      const includeGlobs = Array.isArray(preset.include)
        ? preset.include
        : (preset.type === 'query' ? ['**/*.md'] : []);
      const excludeGlobs = Array.isArray(preset.exclude) ? preset.exclude : [];

      const inc = buildMatcher(includeGlobs);
      const exc = buildMatcher(excludeGlobs);

      // type: 'base' â€” ë‹¨ê±´ ì§€ì •
      if (preset.type === 'base' && typeof preset.base === 'string') {
        const wantedForms = candidateForms(preset.base);
        const found = bases.find(b => {
          const forms = candidateForms(b.base);
          // ì§ì ‘ ì¼ì¹˜ + íŒŒì¼ëª… end-with ë³´ì¡°
          const direct = forms.some(f => wantedForms.includes(f));
          const endWith = fileNameOf(forms[0]) === fileNameOf(wantedForms[0]);
          return direct || endWith;
        });
        const list = found ? [found.base] : [];
        console.debug('[preset:base]', preset.id, 'wanted:', preset.base, 'â†’', list);
        return list;
      }

      // type: 'query' â€” ë‹¤ê±´ ë§¤ì¹­
      if (preset.type === 'query') {
        const matched = bases
          .map(b => b.base)
          .filter(basePath => {
            const forms = candidateForms(basePath);
            const inOk = inc.anyMatch(forms);
            const exOk = exc.noneMatch(forms);
            if (inOk && exOk) return true;

            // ì¶”ê°€ ë³´ì¡°: includeê°€ "ì •í™• íŒŒì¼ëª…ë“¤"ë¡œë§Œ êµ¬ì„±ëœ ê²½ìš° íŒŒì¼ëª…ë§Œ ë¹„êµ í—ˆìš©
            const incAreFilenamesOnly =
              (preset.include || []).length > 0 &&
              (preset.include || []).every(x => !String(x).includes('*') && !String(x).includes('?') && !String(x).includes('**'));
            if (incAreFilenamesOnly) {
              const myFile = fileNameOf(forms[0]);
              const incFiles = new Set((preset.include || []).map(fileNameOf));
              if (incFiles.has(myFile) && exOk) return true;
            }
            return false;
          });

        console.debug('[preset:query]', preset.id,
          'include:', includeGlobs, 'exclude:', excludeGlobs,
          'candidates:', bases.length, 'matched:', matched.length);
        return matched;
      }

      return [];
    }

    
    // í”„ë¦¬ì…‹ ì„ íƒê¸° ì´ˆê¸°í™”
    async function initPresetSelector() {
      try {
        const presetData = await fetchPresets();
        const selector = document.getElementById('presetSelector');
        
        // ê¸°ì¡´ ì˜µì…˜ë“¤ ì œê±° (ì²« ë²ˆì§¸ ì œì™¸)
        while (selector.options.length > 1) {
          selector.remove(1);
        }
        
        // ì¹´í…Œê³ ë¦¬ë³„ë¡œ í”„ë¦¬ì…‹ ê·¸ë£¹í™”
        const groupedPresets = {};
        presetData.presets.forEach(preset => {
          const category = preset.category || 'other';
          if (!groupedPresets[category]) {
            groupedPresets[category] = [];
          }
          groupedPresets[category].push(preset);
        });
        
        // ì¹´í…Œê³ ë¦¬ë³„ë¡œ ì˜µì…˜ ê·¸ë£¹ ìƒì„±
        Object.keys(groupedPresets).forEach(categoryId => {
          const category = presetData.categories[categoryId];
          const optgroup = document.createElement('optgroup');
          optgroup.label = category ? category.name : categoryId;
          
          groupedPresets[categoryId].forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            option.title = preset.description;
            optgroup.appendChild(option);
          });
          
          selector.appendChild(optgroup);
        });
        
        console.log('í”„ë¦¬ì…‹ ì„ íƒê¸° ì´ˆê¸°í™” ì™„ë£Œ:', presetData.presets.length, 'ê°œ í”„ë¦¬ì…‹');
      } catch (e) {
        console.error('í”„ë¦¬ì…‹ ì„ íƒê¸° ì´ˆê¸°í™” ì‹¤íŒ¨:', e);
      }
    }

    // ì„ íƒëœ í”„ë¦¬ì…‹ ë¡œë”©

    async function loadPresetFromSelector() {
      const selector = document.getElementById('presetSelector');
      const selectedPresetId = selector.value;

      if (!selectedPresetId) {
        // ì•„ë¬´ ê²ƒë„ ì„ íƒ ì•ˆ ë˜ì—ˆìœ¼ë©´ ë¦¬í„´ (ì•Œë¦¼ì€ ìƒëµ)
        return;
      }

      try {
        const [presetData, files] = await Promise.all([fetchPresets(), fetchFilesJson()]);
        const selectedPreset = presetData.presets.find(p => p.id === selectedPresetId);

        if (!selectedPreset) {
          alert('ì„ íƒëœ í”„ë¦¬ì…‹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          return;
        }

        const basesIndex = buildBaseIndex(files);

        // ì „ì²´ ì´ˆê¸°í™”
        $rules.innerHTML = '';
        
        const basePaths = await expandPresetToBases(selectedPreset, basesIndex);
        console.log('basePaths:', basePaths);

        if (basePaths.length === 0) {
          alert('í”„ë¦¬ì…‹ì— í•´ë‹¹í•˜ëŠ” íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          return;
        }

        // ê° baseì— ëŒ€í•´ KR/EN ë¡œë“œ â†’ ì¹´ë“œ ìƒì„±
        for (const basePath of basePaths) {
          const [krContent, enContent] = await loadPairForBase(files, basePath);

          const scope = selectedPreset.scope || (selectedPreset.defaults && selectedPreset.defaults.scope) || 'Auto';
          const globs = selectedPreset.globs || (selectedPreset.defaults && selectedPreset.defaults.globs) || '**/*';

          let desc = selectedPreset.desc || (selectedPreset.defaults && selectedPreset.defaults.desc) || '';
          if (!desc) {
            const baseName = basePath.split('/').pop().replace(/\.md$/,'').replace(/[-_]/g,' ');
            const prefix = (selectedPreset.defaults && selectedPreset.defaults.descPrefix) ? selectedPreset.defaults.descPrefix : '';
            desc = (prefix + baseName).replace(/^\w/, c => c.toUpperCase());
          }

          await addRule({
            desc,
            scope,
            globs,
            bodyKr: krContent || '',
            bodyEn: enContent || '',
            basePath: basePath
          });
        }

        console.log(`í”„ë¦¬ì…‹ '${selectedPreset.name}' ë¡œë”© ì™„ë£Œ:`, basePaths.length, 'ê°œ ê·œì¹™');
      } catch (e) {
        console.error('í”„ë¦¬ì…‹ ë¡œë”© ì‹¤íŒ¨:', e);
        alert('í”„ë¦¬ì…‹ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    }

    document.getElementById('presetSelector').addEventListener('change', loadPresetFromSelector);

    // Toolbar actions
    document.getElementById('addRule').onclick = () => addRule({ scope: 'Auto', globs: '**/*' });

    document.getElementById('clearAll').onclick = () => { $rules.innerHTML = ''; };

    document.getElementById('downloadAll').onclick = () => {
      const cards = Array.from($rules.querySelectorAll('.rule'));
      if (!cards.length){ alert('ê·œì¹™ì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ì¶”ê°€í•˜ì„¸ìš”.'); return; }
      for (const card of cards){
        const data = ruleFromCard(card);
        const out = buildMDC(data);
        const name = mdcNameFromSelectedValue(card.querySelector('.f-name').value);
        downloadText(name, out);
      }
    };


    // document.getElementById('loadDefaults').onclick = () => {
    //   $rules.innerHTML = '';
    //   // 00: Security baseline (Always)
    //   addRule({
    //     name: '00-security.mdc',
    //     desc: 'Organization Security & Secrets Baseline',
    //     scope: 'Always',
    //     globs: '**/*',
    //     body: `# Security & Secrets\n\n- ì‹œí¬ë¦¿/í† í°/ìê²©ì¦ëª…/PIIëŠ” ì¶œë ¥Â·ë³µì‚¬Â·í•˜ë“œì½”ë”© ê¸ˆì§€.\n- ì˜ì‹¬ ë¬¸ìì—´(AccessKey, PrivateKey, JWT ë“±) ê°ì§€ ì‹œ ì¦‰ì‹œ ì¤‘ë‹¨Â·ë§ˆìŠ¤í‚¹.\n- ì•ˆì „í•œ ëŒ€ì²´: í™˜ê²½ë³€ìˆ˜/ì‹œí¬ë¦¿ ë§¤ë‹ˆì € ì‚¬ìš© ê°€ì´ë“œ ì œì‹œ.\n- ì™¸ë¶€ ì „ì†¡/í•™ìŠµ ì¶”ì • ì‘ì—…ì€ ë³´ë¥˜í•˜ê³  ë‚´ë¶€ ëŒ€ì²´ ì ˆì°¨ ì œì•ˆ.\n- ì»¤ë°‹/PR ì‹œ ë¹„ê³µê°œ ì •ë³´ê°€ í¬í•¨ë˜ì§€ ì•Šë„ë¡ ì ê²€ ì²´í¬ë¦¬ìŠ¤íŠ¸ ì œê³µ.`
    //   });
    //   // 10: Git style (Auto)
    //   addRule({
    //     name: '10-git-style.mdc',
    //     desc: 'Git commit/pr style (sentence-style)',
    //     scope: 'Auto',
    //     globs: '**/*',
    //     body: `# Git & Commit Style\n\n- ì»¤ë°‹ ë©”ì‹œì§€ëŠ” ë¬¸ì¥í˜•Â·ê°„ê²°ì²´(Conventional ë¯¸ì‚¬ìš©).\n  - ì˜ˆ: 'Fix PS1 prompt escaping for zsh.'\n- PR ë³¸ë¬¸ 3ì¤„ ê·œì•½: ë³€ê²½ ìš”ì•½ / ì˜í–¥ ë²”ìœ„ / ë¡¤ë°± ë°©ë²•.\n- ëŒ€ê·œëª¨ ë³€ê²½ ì‹œ ë§ˆì´ê·¸ë ˆì´ì…˜ ë‹¨ê³„ì™€ ë¦¬ìŠ¤í¬ ìš”ì•½.`
    //   });
    //   // 20: Stack example (Auto)
    //   addRule({
    //     name: '20-node-react.mdc',
    //     desc: 'Node 22 + React/Vite defaults',
    //     scope: 'Auto',
    //     globs: '**/*',
    //     body: `# Node/React/Vite Defaults\n\n- Node 22, ESLint + typescript-eslint ì‚¬ìš©.\n- Route-level dynamic import, í°íŠ¸/ì•„ì´ì½˜ì€ WOFF2 ìš°ì„ .\n- ë²ˆë“¤ ì „/í›„ ë¹„êµí‘œì™€ ì„ íƒ ê¸°ì¤€ 3ì¤„ ìš”ì•½.`
    //   });
    //   // 90: Project overrides (Auto)
    //   addRule({
    //     name: '90-project-overrides.mdc',
    //     desc: 'This repository specific rules (overrides/additions)',
    //     scope: 'Auto',
    //     globs: '**/*',
    //     body: `# Project Overrides\n\n- ì´ ë¦¬í¬ì§€í† ë¦¬ì˜ í´ë” êµ¬ì¡°Â·í™˜ê²½ë³€ìˆ˜ í‚¤Â·ì—”ë“œí¬ì¸íŠ¸ ë“± êµ¬ì²´í™”ë¥¼ ì—¬ê¸°ì— ê¸°ë¡.\n- ê³µí†µ ê·œì¹™ì„ ì•½í™”ì‹œí‚¤ëŠ” ë‚´ìš©ì€ ê¸ˆì§€(ë³´ì•ˆ ì„¹ì…˜ override deny).`
    //   });
    // };
    
  </script>
</body>
</html>