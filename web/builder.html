<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cursor Rules Builder — offline</title>
  <style>
    :root { --gap: 12px; --radius: 12px; }
    * { box-sizing: border-box; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; background: #0b1220; color: #e8eefb; }
    header { padding: 20px; border-bottom: 1px solid #21314f; background: #0e1628; position: sticky; top: 0; z-index: 5; }
    h1 { margin: 0 0 8px; font-size: 20px; }
    .sub { opacity: .85; font-size: 13px; }
    main { padding: 20px; display: grid; gap: var(--gap); max-width: 1100px; margin: 0 auto; }
    .row { display: flex; flex-wrap: wrap; gap: var(--gap); align-items: center; }
    .card { background: #101a30; border: 1px solid #22365c; border-radius: var(--radius); padding: 16px; }
    .toolbar .btn { margin-right: 8px; }
    .btn { background: #1c2b4b; color: #e8eefb; border: 1px solid #2a4476; padding: 10px 14px; border-radius: 10px; cursor: pointer; font-weight: 600; }
    .btn:hover { background: #24365f; }
    .btn.ghost { background: transparent; border-color: #2a4476; }
    .btn.warn { background: #3b2640; border-color: #6a2b70; }
    .grid { display: grid; gap: var(--gap); }
    .fields { display: grid; gap: var(--gap); grid-template-columns: repeat(2, 1fr); }
    .field { display: grid; gap: 6px; }
    .field label { font-size: 12px; opacity: .9; }
    input[type="text"], textarea, select { background: #0c1527; color: #e8eefb; border: 1px solid #29406c; border-radius: 10px; padding: 10px 12px; font: inherit; }
    textarea { min-height: 140px; width: 100%; }
    .rule { position: relative; }
    .rule h3 { margin: 0 0 8px; font-size: 16px; }
    .rule-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .muted { opacity: .75; font-size: 12px; }
    .hl { color: #b0c9ff; }
    .footer-actions { display: flex; gap: 10px; flex-wrap: wrap; }
    code.inline { background: #0c1527; padding: 2px 6px; border-radius: 6px; border:1px solid #22365c; }
    .out { white-space: pre; background: #0c1527; padding: 12px; border:1px solid #22365c; border-radius: 10px; overflow:auto; }
  </style>
</head>
<body>
  <header>
    <h1>Cursor Rules Builder <span class="sub">— ".mdc" 파일을 만들어 <code class="inline">.cursor/rules</code>에 붙여넣기</span></h1>
    <div class="sub">오프라인 단일 HTML. 공통/프로젝트 지침을 입력하고, frontmatter(<code class="inline">alwaysApply</code>, <code class="inline">globs</code>)가 포함된 .mdc를 생성합니다.</div>
  </header>

  <main>
    <section class="card toolbar">
      <div class="row">
        <button class="btn" id="addRule">+ 규칙 추가</button>
        <button class="btn" id="loadDefaults">보안 기본 + 프로젝트 템플릿 불러오기</button>
        <button class="btn" id="loadPresets">프리셋 불러오기</button>
        <button class="btn" id="downloadAll">모든 규칙 .mdc 저장</button>
        <button class="btn ghost" id="clearAll">초기화</button>
      </div>
      <div class="muted" style="margin-top:8px;">TIP: 공통 규칙은 <span class="hl">Scope = Always</span>로 설정하면 전 리포에서 항상 로드됩니다. 프로젝트 특화 규칙은 보통 <span class="hl">Scope = Auto</span>로 두고, <code class="inline">globs</code>는 <code class="inline">**/*</code>로 유지하세요.</div>
    </section>

    <section id="rules" class="grid"></section>

  </main>

  <template id="ruleTmpl">
    <div class="card rule">
      <h3>규칙</h3>
      <div class="fields">
        <div class="field">
          <label>파일명 (.mdc)</label>
          <select class="f-name">
            <option value="">-- 파일을 선택하세요 --</option>
          </select>
          <button type="button" class="btn" style="margin-top: 5px;" data-action="load-file-content">파일 내용 불러오기</button>
        </div>
        <div class="field">
          <label>설명 (description)</label>
          <input type="text" class="f-desc" placeholder="Organization Security Baseline" />
        </div>
        <div class="field">
          <label>Scope</label>
          <select class="f-scope">
            <option>Always</option>
            <option selected>Auto</option>
            <option>Manual</option>
          </select>
        </div>
        <div class="field">
          <label>globs (Auto/Always에서만 사용, 예: **/*)</label>
          <input type="text" class="f-globs" placeholder="**/*" />
        </div>
      </div>
      <div class="field" style="margin-top:12px;">
        <label>내용 (Markdown 본문)</label>
        <textarea class="f-body" placeholder="# 제목..."></textarea>
      </div>
      <div class="rule-actions" style="margin-top:12px;">
        <button class="btn" data-action="preview">미리보기</button>
        <button class="btn" data-action="copy">내용 복사</button>
        <button class="btn" data-action="download">.mdc 저장</button>
        <button class="btn warn" data-action="remove">삭제</button>
      </div>
      <details style="margin-top:10px;">
        <summary>생성 결과 미리보기</summary>
        <pre class="out"></pre>
      </details>
    </div>
  </template>

  <script>
    const $rules = document.getElementById('rules');
    const tmpl = document.getElementById('ruleTmpl');

    // 페이지 로드 시 파일 목록 가져오기
    document.addEventListener('DOMContentLoaded', async () => {
        await loadMdFileList();
    });

    // .md 파일 목록 가져오기 (정적 JSON 파일 사용)
    async function loadMdFileList() {
        try {
            const response = await fetch('files.json');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const files = await response.json();
            
            // 템플릿의 select 요소에 파일 목록 추가 (새로 추가되는 규칙용)
            const templateSelects = tmpl.content.querySelectorAll('select.f-name');
            templateSelects.forEach(templateSelect => {
                // 기존 옵션 제거 (기본 옵션 제외)
                while (templateSelect.options.length > 1) {
                    templateSelect.remove(1);
                }
                // 새 파일 목록 추가 (path만 표시)
                files.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.path;
                    option.textContent = file.path;
                    templateSelect.appendChild(option);
                });
            });
            
            // 모든 규칙 카드의 select 요소에 파일 목록 추가
            document.querySelectorAll('.rule select.f-name').forEach(select => {
                // 기존 옵션 제거 (기본 옵션 제외)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                // 새 파일 목록 추가 (path만 표시)
                files.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.path;
                    option.textContent = file.path;
                    select.appendChild(option);
                });
            });
        } catch (error) {
            console.error('파일 목록을 불러오는 중 오류 발생:', error);
        }
    }

    function escapeYaml(str){
      if (!str) return '';
      // escape double quotes, newlines aren't used in description
      return String(str).replace(/"/g, '"');
    }

    function buildFrontmatter({desc, scope, globs}){
      const lines = ['---'];
      if (desc && desc.trim()) lines.push(`description: "${escapeYaml(desc.trim())}"`);
      if (scope === 'Always') lines.push('alwaysApply: true');
      if ((scope === 'Always' || scope === 'Auto') && globs && globs.trim()){
        lines.push('globs:');
        // support comma or whitespace separated patterns
        const parts = globs.split(/[,\n]/).map(s => s.trim()).filter(Boolean);
        for (const p of parts){ lines.push(`  - "${p.replace(/"/g, '"')}"`); }
      }
      lines.push('---');
      return lines.join('\n');
    }

    function buildMDC({name, desc, scope, globs, body}){
      const fm = buildFrontmatter({desc, scope, globs});
      return fm + '\n\n' + (body ? body.trim() : '') + '\n';
    }

    function ruleFromCard(card){
      return {
        name: card.querySelector('.f-name').value.trim(),
        desc: card.querySelector('.f-desc').value,
        scope: card.querySelector('.f-scope').value,
        globs: card.querySelector('.f-globs').value,
        body: card.querySelector('.f-body').value
      };
    }

    function setPreview(card, text){ card.querySelector('.out').textContent = text; }

    function downloadText(filename, text){
      const blob = new Blob([text], {type: 'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename || 'rule.mdc';
      document.body.appendChild(a); a.click();
      a.remove(); URL.revokeObjectURL(url);
    }

    // .md 파일 목록 가져오기
    async function loadMdFileList() {
        try {
            const response = await fetch('/list-md-files');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const files = await response.json();
            
            // 모든 규칙 카드의 select 요소에 파일 목록 추가
            document.querySelectorAll('.rule select.f-name').forEach(select => {
                // 기존 옵션 제거 (기본 옵션 제외)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                // 새 파일 목록 추가
                files.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file;
                    option.textContent = file;
                    select.appendChild(option);
                });
            });
        } catch (error) {
            console.error('파일 목록을 불러오는 중 오류 발생:', error);
        }
    }

    async function addRule(prefill){
      const node = tmpl.content.firstElementChild.cloneNode(true);
      if (prefill){
        // 파일명은 select 옵션에서 선택하도록 하므로 prefill은 생략
        // node.querySelector('.f-name').value = prefill.name || '';
        node.querySelector('.f-desc').value = prefill.desc || '';
        node.querySelector('.f-scope').value = prefill.scope || 'Auto';
        node.querySelector('.f-globs').value = prefill.globs || '';
        node.querySelector('.f-body').value = prefill.body || '';
      }
      
      // 파일 목록 로드
      await loadMdFileListForNewRule(node);
      
      node.addEventListener('click', async (e) => {
        const action = e.target.dataset.action;
        if (!action) return;
        const data = ruleFromCard(node);
        if (action === 'preview'){
          const out = buildMDC(data);
          setPreview(node, out);
        } else if (action === 'copy'){
          const out = buildMDC(data);
          navigator.clipboard.writeText(out).then(() => {
            e.target.textContent = '복사됨';
            setTimeout(() => e.target.textContent = '내용 복사', 1200);
          });
        } else if (action === 'download'){
          const out = buildMDC(data);
          const name = data.name || 'rule.mdc';
          downloadText(name, out);
        } else if (action === 'remove'){
          node.remove();
        } else if (action === 'load-file-content') {
            const selectedFile = node.querySelector('.f-name').value;
            if (!selectedFile) {
                alert('파일을 먼저 선택하세요.');
                return;
            }
            try {
                // 먼저 files.json에서 해당 파일의 raw_url을 찾기
                const fileListResponse = await fetch('files.json');
                if (!fileListResponse.ok) {
                    throw new Error(`HTTP error! status: ${fileListResponse.status}`);
                }
                const files = await fileListResponse.json();
                const file = files.find(f => f.path === selectedFile);
                
                if (!file || !file.raw_url) {
                    alert('파일의 raw URL을 찾을 수 없습니다.');
                    return;
                }
                
                // raw URL을 통해 파일 내용 가져오기
                const response = await fetch(file.raw_url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const content = await response.text();
                node.querySelector('.f-body').value = content;
                
                // 파일명에서 .md 확장자를 제거하고 .mdc로 변경
                const mdcFilename = selectedFile.replace(/\.md$/, '.mdc');
                node.querySelector('.f-name').value = mdcFilename;
                
                // 설명도 자동으로 채우기 (파일명 기반)
                const desc = mdcFilename.replace(/\.mdc$/, '').replace(/[-_]/g, ' ');
                node.querySelector('.f-desc').value = desc.charAt(0).toUpperCase() + desc.slice(1) + ' (from ' + selectedFile + ')';
            } catch (error) {
                console.error('파일 내용을 불러오는 중 오류 발생:', error);
                alert('파일 내용을 불러오는 데 실패했습니다.');
            }
        }
      });
      $rules.appendChild(node);
    }
    
    // 새로운 규칙 카드에 파일 목록 로드 (정적 JSON 파일 사용)
    async function loadMdFileListForNewRule(ruleNode) {
        try {
            const response = await fetch('files.json');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const files = await response.json();
            
            // 새로운 규칙 카드의 select 요소에 파일 목록 추가
            const select = ruleNode.querySelector('select.f-name');
            if (select) {
                // 기존 옵션 제거 (기본 옵션 제외)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                // 새 파일 목록 추가 (path만 표시)
                files.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.path;
                    option.textContent = file.path;
                    select.appendChild(option);
                });
            }
        } catch (error) {
            console.error('파일 목록을 불러오는 중 오류 발생:', error);
        }
    }

    // Toolbar actions
    document.getElementById('addRule').onclick = () => addRule({ scope: 'Auto', globs: '**/*' });

    document.getElementById('clearAll').onclick = () => { $rules.innerHTML = ''; };

    document.getElementById('downloadAll').onclick = () => {
      const cards = Array.from($rules.querySelectorAll('.rule'));
      if (!cards.length){ alert('규칙이 없습니다. 먼저 추가하세요.'); return; }
      for (const card of cards){
        const data = ruleFromCard(card);
        const out = buildMDC(data);
        downloadText(data.name || 'rule.mdc', out);
      }
    };

    document.getElementById('loadDefaults').onclick = () => {
      $rules.innerHTML = '';
      // 00: Security baseline (Always)
      addRule({
        name: '00-security.mdc',
        desc: 'Organization Security & Secrets Baseline',
        scope: 'Always',
        globs: '**/*',
        body: `# Security & Secrets\n\n- 시크릿/토큰/자격증명/PII는 출력·복사·하드코딩 금지.\n- 의심 문자열(AccessKey, PrivateKey, JWT 등) 감지 시 즉시 중단·마스킹.\n- 안전한 대체: 환경변수/시크릿 매니저 사용 가이드 제시.\n- 외부 전송/학습 추정 작업은 보류하고 내부 대체 절차 제안.\n- 커밋/PR 시 비공개 정보가 포함되지 않도록 점검 체크리스트 제공.`
      });
      // 10: Git style (Auto)
      addRule({
        name: '10-git-style.mdc',
        desc: 'Git commit/pr style (sentence-style)',
        scope: 'Auto',
        globs: '**/*',
        body: `# Git & Commit Style\n\n- 커밋 메시지는 문장형·간결체(Conventional 미사용).\n  - 예: 'Fix PS1 prompt escaping for zsh.'\n- PR 본문 3줄 규약: 변경 요약 / 영향 범위 / 롤백 방법.\n- 대규모 변경 시 마이그레이션 단계와 리스크 요약.`
      });
      // 20: Stack example (Auto)
      addRule({
        name: '20-node-react.mdc',
        desc: 'Node 22 + React/Vite defaults',
        scope: 'Auto',
        globs: '**/*',
        body: `# Node/React/Vite Defaults\n\n- Node 22, ESLint + typescript-eslint 사용.\n- Route-level dynamic import, 폰트/아이콘은 WOFF2 우선.\n- 번들 전/후 비교표와 선택 기준 3줄 요약.`
      });
      // 90: Project overrides (Auto)
      addRule({
        name: '90-project-overrides.mdc',
        desc: 'This repository specific rules (overrides/additions)',
        scope: 'Auto',
        globs: '**/*',
        body: `# Project Overrides\n\n- 이 리포지토리의 폴더 구조·환경변수 키·엔드포인트 등 구체화를 여기에 기록.\n- 공통 규칙을 약화시키는 내용은 금지(보안 섹션 override deny).`
      });
    };

    // 프리셋 불러오기
    document.getElementById('loadPresets').onclick = () => {
      $rules.innerHTML = '';
      // Python FastAPI
      addRule({
        name: 'python-fastapi.mdc',
        desc: 'Python 3.13 + FastAPI defaults',
        scope: 'Auto',
        globs: '**/*',
        body: `# Python/FastAPI Defaults\n\n- Python 3.13, 타입힌트 필수, mypy --strict 통과 기준.\n- FastAPI 스캐폴딩 시 pydantic v2 기준.\n- 동기/비동기 혼용 금지, 라우터/스키마/서비스 레이어 모듈 분리.`
      });
      // Docker DevOps
      addRule({
        name: 'docker-devops.mdc',
        desc: 'Dockerfile & DevOps defaults',
        scope: 'Auto',
        globs: '**/*',
        body: `# Docker/DevOps Defaults\n\n- Dockerfile은 멀티스테이지 + alpine 기본.\n- Buildx, 캐시 전략(브랜치 스코프) 반영.\n- docker-compose는 .env.local 전제로 설계. .env 하드 의존 금지.\n- 이미지 최적화(패키지 제거, 압축) 및 --platform 표기 유지.`
      });
      // DB Prisma
      addRule({
        name: 'db-prisma.mdc',
        desc: 'Prisma ORM defaults',
        scope: 'Auto',
        globs: '**/*',
        body: `# Prisma Defaults\n\n- 컴포지트 키/관계 명명 규칙 준수.\n- 마이그레이션은 리뷰 후 적용.\n- 다운 마이그레이션 경로 필수.`
      });
      // UI Tailwind
      addRule({
        name: 'ui-tailwind.mdc',
        desc: 'Tailwind CSS defaults',
        scope: 'Auto',
        globs: '**/*',
        body: `# Tailwind CSS Defaults\n\n- 사내 iris 팔레트 토큰 우선 사용.\n- 새 색상 제안 금지, 필요 시 토큰 맵핑 테이블 포함.\n- 반응형 디자인과 접근성 고려.`
      });
    };

    // Start empty
    // addRule({ scope: 'Auto', globs: '**/*' });
  </script>
</body>
</html>